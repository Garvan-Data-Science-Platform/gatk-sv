##########################
## EXPERIMENTAL WORKFLOW
##########################

version 1.0 

import "Structs.wdl"
import "Module07FilterOutlierSamples.wdl" as FilterSingle
import "Module07OutlierSampleExclusionHelper.wdl" as ScatteredExclusion

# This is an analysis WDL that wraps Module07FilterOutlierSamples.wdl and 
# applies it in parallel across multiple input VCFs.


workflow FilterOutlierSamplesPostHocMultiVcf {
  input {
    Array[File] vcfs
    Array[File] vcf_idxs
    File? pcrplus_samples_list
    Int? n_iqr_cutoff_pcrplus
    Int n_iqr_cutoff_pcrminus
    Int records_per_shard
    String prefix
    File autosomes_fai

    String sv_pipeline_docker
    String sv_pipeline_base_docker
    String sv_base_mini_docker

    RuntimeAttr? runtime_overide_shard_vcf
    RuntimeAttr? runtime_overide_concat_shards
  }

  Array[Pair[File, File]] vcf_pairs = zip(vcfs, vcf_idxs)
  Boolean PCRPLUS = defined(pcrplus_samples_list)

  # Get count of biallelic autosomal variants per sample for each VCF
  scatter ( vcf_info in vcf_pairs ) {
    call FilterSingle.FilterOutlierSamplesPostHoc as CollectData {
      input:
        vcf=vcf_info.left,
        vcf_idx=vcf_info.right,
        pcrplus_samples_list=pcrplus_samples_list,
        records_per_shard=records_per_shard,
        prefix=prefix,
        autosomes_fai=autosomes_fai,
        collect_data_only=true,
        output_sharded_vcf=true,
        sv_pipeline_docker=sv_pipeline_docker,
        sv_pipeline_base_docker=sv_pipeline_base_docker,
        sv_base_mini_docker=sv_base_mini_docker,
        runtime_overide_shard_vcf=runtime_overide_shard_vcf
    }
    Array[File] sharded_vcfs = select_first([CollectData.sharded_input_vcf])
    Array[File] sharded_vcf_idxs = select_first([CollectData.sharded_input_vcf_idxs])
  }
  call FilterSingle.CombineCounts as Combine {
    input:
      svcounts=CollectData.svcounts_per_sample_data,
      prefix=prefix,
      sv_pipeline_base_docker=sv_pipeline_base_docker
  }
  File all_samples_list = CollectData.all_samples_list[0]
  File plus_samples_list = CollectData.plus_samples_list[0]
  File minus_samples_list = CollectData.minus_samples_list[0]

  # Get outliers
  if (PCRPLUS) {
    call FilterSingle.IdentifyOutliers as IdentifyPlusOutliers {
      input:
        svcounts=Combine.summed_svcounts,
        n_iqr_cutoff=select_first([n_iqr_cutoff_pcrplus]),
        samples_list=plus_samples_list,
        prefix="~{prefix}.PCRPLUS",
        sv_pipeline_docker=sv_pipeline_docker
    }
  }
  call FilterSingle.IdentifyOutliers as IdentifyMinusOutliers {
    input:
      svcounts=Combine.summed_svcounts,
      n_iqr_cutoff=n_iqr_cutoff_pcrminus,
      samples_list=minus_samples_list,
      prefix="~{prefix}.PCRMINUS",
      sv_pipeline_docker=sv_pipeline_docker
  }

  # Write new list of samples without outliers
  call FilterSingle.FilterSampleList as FilterList {
    input:
      original_samples_list=all_samples_list,
      outlier_samples=Exclude.excluded_samples[0],
      prefix=prefix,
      sv_pipeline_docker=sv_pipeline_docker
  }

  # Exclude outliers from vcf shards generated by CollectData
  Array[Pair[Array[File], Array[File]]] shard_info_pairs = zip(sharded_vcfs, sharded_vcf_idxs)
  scatter ( shard_info in shard_info_pairs ) {
    call ScatteredExclusion.ScatteredSampleExclusion as Exclude {
      input:
        vcfs=shard_info.left,
        vcf_idxs=shard_info.right,
        plus_outliers_list=IdentifyPlusOutliers.outliers_list,
        minus_outliers_list=IdentifyMinusOutliers.outliers_list,
        prefix=prefix,
        sv_base_mini_docker=sv_base_mini_docker
    }
  }

  # Final outputs
  output {
    Array[File] vcfs_noOutliers = Exclude.filtered_vcf
    Array[File] vcf_noOutliers_idx = Exclude.filtered_vcf_idx
    File nooutliers_samples_list = FilterList.filtered_samples_list
    File excluded_samples_list = Exclude.excluded_samples[0]
    File svcounts_per_sample_data = Combine.summed_svcounts
    File? svcounts_per_sample_plots_PCRPLUS = IdentifyPlusOutliers.svcount_distrib_plots
    File svcounts_per_sample_plots_PCRMINUS = IdentifyMinusOutliers.svcount_distrib_plots
  }
}
